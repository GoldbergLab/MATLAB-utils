function [tuneParameters, tuneFunction] = imtune(imageData)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% imtune: A GUI for generating image adjustment parameters
% usage:  [tuneParameters, tuneFunction] = imtune(imageData)
%
% where,
%    imageData is a H x W or H x W x 3 array representing an image
%    tuneParameters is a struct containing image tuning parameters, such as
%       minVal and maxVal
%    tuneFunction is a function that takes an image array and applies the 
%       tuning parameters generated by the GUI, returning a modified image 
%       array.
%
% This is a function similar to imcontrast. It generates a GUI allowing the
%   user to adjust image parameters. It returns the selected image tuning
%   parameters, as well as a function that applies the selected parameters
%   to an image.
%
% See also: imcontrast
%
% Version: 1.0
% Author:  Brian Kardon
% Email:   bmk27=cornell*org, brian*kardon=google*com
% Real_email = regexprep(Email,{'=','*'},{'@','.'})
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Standardize image format, check for RGB color channel
if ndims(imageData) == 3
    % Appears to have multiple color channels
    otherChannels = 1:ndims(imageData);
    colorChannel = find(size(imageData) == 3, 1);
    if isempty(colorChannel)
        % Perhaps it was a singleton dimension
        imageData = squeeze(imageData);
    else
        % Found the color channel
        otherChannels(otherChannels == colorChannel) = [];
        imageData = permute(imageData, [otherChannels, colorChannel]);
        colorChannel = ndims(imageData);
    end 
else
    % Grayscale image
    colorChannel = [];
end

% Create GUI figure
f = figure('Toolbar', 'none', 'Menubar', 'none', 'NumberTitle', false, ...
            'Name', 'imtune', ...
            'WindowButtonMotionFcn', @mouseMotionHandler, ...
            'WindowButtonDownFcn', @mouseButtonDownHandler, ...
            'WindowButtonUpFcn', @mouseButtonUpHandler, ...
            'CloseRequestFcn', @closeFunction);

% Create axes for image
ax1 = axes(f, 'Units', 'normalized', 'Position', [0.05, 0.2, 0.9, 0.75]);
hold(ax1, 'on');
% Create axes for histogram
ax2 = axes(f, 'Units', 'normalized', 'Position', [0.05, 0.05, 0.75, 0.15]);
hold(ax2, 'on');

% Create apply & cancel buttons
applyButton = uicontrol(f, 'Units', 'normalized', ...
    'Style','pushbutton', 'String', 'Apply', ...
    'Position', [0.825, 0.13, 0.15, 0.07], 'Callback', @applyFunction);
CancelButton = uicontrol(f, 'Units', 'normalized', ...
    'Style','pushbutton', 'String', 'Cancel', ...
    'Position', [0.825, 0.05, 0.15, 0.07], 'Callback', @cancelFunction);

% Display image
im = imshow(imageData, 'Parent', ax1);

% Display histogram
if isempty(colorChannel)
    histogram(imageData(:))
else
    axis(ax2, 'auto');
    r = imageData(:, :, 1);
    g = imageData(:, :, 2);
    b = imageData(:, :, 3);
    histogram(r(:), 'Parent', ax2, 'FaceColor', 'red',   'EdgeColor', 'red');
    histogram(g(:), 'Parent', ax2, 'FaceColor', 'green', 'EdgeColor', 'green');
    histogram(b(:), 'Parent', ax2, 'FaceColor', 'blue',  'EdgeColor', 'blue');
    axis(ax2, 'manual');
end

% Get maximum possible value for this image data type
maxVal = getMaxVal(imageData);

% Set x limits for histogram
xlim(ax2, [-maxVal*0.05, maxVal*1.05]);

yl = ylim(ax2);

% Create selection box
p = rectangle('Position', [0, 0, maxVal, diff(yl)], 'FaceColor', [1, 0, 0, 0.1]);

% Store important GUI info
f.UserData.maxVal = maxVal;
f.UserData.OriginalImageData = imageData;
f.UserData.Image = im;
f.UserData.Highlight = p;
f.UserData.HistogramAxes = ax2;
f.UserData.Dragging = [false, false];
f.UserData.DragMargin = 0.03;
f.UserData.Immortal = true;

% Wait for user to finish with GUI
uiwait(f);

% Get tune parameters from GUI
tuneParameters = getParams(f);

% Create tune function
if tuneParameters.minVal == 0 && tuneParameters.maxVal == maxVal
    % Params didn't change
    tuneFunction = @(imageData)imageData;
else
    tuneFunction = @(imageData)tuneImage(imageData, tuneParameters);
end

% Destroy GUI
f.UserData.Immortal = false;
delete(f);

function maxVal = getMaxVal(imageData)
% Get maximum possible value for image data type

imageClass = class(imageData);

switch imageClass
    case 'uint8'
        maxVal = 2^8-1;
    case 'uint16'
        maxVal = 2^16-1;
    case 'int16'
        maxVal = 2^15-1;
    case 'double'
        maxVal = 1;
    otherwise
        error('Unrecognized image class: %s', imageClass);
end

function params = getParams(fig)
% Collect image tune parameters from GUI
params.minVal = fig.UserData.Highlight.Position(1);
params.maxVal = fig.UserData.Highlight.Position(1) + fig.UserData.Highlight.Position(3);

function newImageData = tuneImage(imageData, params)
% Tune image according to current parameters

newMinVal = params.minVal;
newMaxVal = params.maxVal;
oldMaxVal = getMaxVal(imageData);

newImageData = imageData;
newImageData(newImageData < newMinVal) = newMinVal;
newImageData(newImageData > newMaxVal) = newMaxVal;
newImageData = (newImageData - newMinVal) * (oldMaxVal / (newMaxVal - newMinVal));

function adjustImagePreview(fig)
% Update image preview
params = getParams(fig);

imageData = fig.UserData.OriginalImageData;
newImageData = tuneImage(imageData, params);
fig.UserData.Image.CData = newImageData;

function closeFunction(fig, ~)
% Close GUI
if ~fig.UserData.Immortal
    delete(fig);
end
uiresume(fig);

function applyFunction(button, ~)
% Export params and close GUI
fig = button.Parent;
closeFunction(fig);

function cancelFunction(button, ~)
% Close GUI without image parameter changes
fig = button.Parent;

% Reset selection before closing
yl = ylim(fig.UserData.HistogramAxes);
fig.UserData.Highlight.Position = [0, 0, fig.UserData.maxVal, diff(yl)];

% Destroy GUI
if ~fig.UserData.Immortal
    delete(fig);
end
uiresume(fig);

function mouseButtonDownHandler(fig, ~)
% Handle mouse dragging
dataPosition = figurePositionToDataPosition(fig.CurrentPoint, fig.UserData.Highlight.Parent);
mousePositionInHighlight = (dataPosition(1:2) - fig.UserData.Highlight.Position(1:2)) ./ fig.UserData.Highlight.Position(3:4);
if mousePositionInHighlight(2) >= 0 && mousePositionInHighlight(2) <= 1
    fig.UserData.Dragging = [false, false];
    if abs(mousePositionInHighlight(1)) < fig.UserData.DragMargin
        fig.UserData.Dragging(1) = true;
    end
    if abs(mousePositionInHighlight(1) - 1) < fig.UserData.DragMargin
        fig.UserData.Dragging(2) = true;
    end
end

function mouseButtonUpHandler(fig, ~)
fig.UserData.Dragging = [false, false];

function mouseMotionHandler(fig, ~)
[dataPosition, inAxes] = figurePositionToDataPosition(fig.CurrentPoint, fig.UserData.Highlight.Parent, true);
mousePositionInHighlight = (dataPosition(1:2) - fig.UserData.Highlight.Position(1:2)) ./ fig.UserData.Highlight.Position(3:4);

if inAxes && mousePositionInHighlight(2) >= 0 && mousePositionInHighlight(2) <= 1 && (abs(mousePositionInHighlight(1)) < fig.UserData.DragMargin || abs(mousePositionInHighlight(1) - 1) < fig.UserData.DragMargin)
    fig.Pointer = 'left';
else
    fig.Pointer = 'arrow';
end

if fig.UserData.Dragging(1)
    oldPosition = fig.UserData.Highlight.Position;
    newPosition = oldPosition;
    newPosition(1) = dataPosition(1);
    newPosition(3) = oldPosition(3) - (newPosition(1) - oldPosition(1));
    if newPosition(3) >= 0
        fig.UserData.Highlight.Position = newPosition;
    else
        fig.UserData.Dragging = [false, true];
        newPosition(1) = oldPosition(1) + oldPosition(3);
        newPosition(3) = abs(newPosition(3));
        fig.UserData.Highlight.Position = newPosition;
    end
    adjustImagePreview(fig);
end
if fig.UserData.Dragging(2)
    oldPosition = fig.UserData.Highlight.Position;
    newPosition = oldPosition;
    newPosition(3) = dataPosition(1) - oldPosition(1);
    if newPosition(3) >= 0
        fig.UserData.Highlight.Position = newPosition;
    else
        fig.UserData.Dragging = [true, false];
        newPosition(1) = oldPosition(1) - abs(newPosition(3));
        newPosition(3) = abs(newPosition(3));
        fig.UserData.Highlight.Position = newPosition;
    end
    adjustImagePreview(fig);
end

% if bottomLeft(2)
%     disp('Bottom');
% end
% if topRight(1)
%     disp('Right');
% end
% if topRight(2)
%     disp('Top');
% end
% if ~any(bottomLeft) && ~any(topRight)
%     disp('None');
% end

function [dataPosition, inAxes] = figurePositionToDataPosition(figPosition, ax, clamp)
if ~exist('clamp', 'var')
    clamp = false;
end

xl = xlim(ax);
yl = ylim(ax);
axesOrigin = [xl(1), yl(1)];
axesWidth = [diff(xl), diff(yl)];
originalAxUnits = ax.Units;
ax.Units = ax.Parent.Units;
dataPosition = (figPosition - ax.Position(1:2)) .* axesWidth ./ ax.Position(3:4) + axesOrigin;
inAxes = dataPosition(1) >= xl(1) && dataPosition(1) <= xl(2) && dataPosition(2) >= yl(1) && dataPosition(2) <= yl(2);
if clamp
    dataOrigin = [0, yl(1)];
    dataEnd = [ax.Parent.UserData.maxVal, yl(1) + yl(2)];
    dataPosition(dataPosition < dataOrigin) = dataOrigin(dataPosition < dataOrigin);
    dataPosition(dataPosition > dataEnd) = dataEnd(dataPosition > dataEnd);
end
ax.Units = originalAxUnits;