function out = fskim(fid, num, type, read, options)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% fskim: Drop-in replacement for fread that by default seeks w/o reading
% usage: out = fskim(fid, num, type)
%        out = fskim(fid, num, type, true)
%        out = fskim(____, 'OutputValue', 0)
%
% where,
%    fid is a file ID, like one generated by fopen
%    num is a number of bytes to read/seek (may be a vector of sizes)
%    type is a valid binary type
%    read is a boolean flag indicating whether or not to actually read
%       the data. Default is false.
%    Name/Value arguments may include:
%       OutputValue - a value to output when read = false. Default is [].
%    out is either [], or OutputValue if supplied when read is false, or 
%       the specified contents of the file if read is true.
%
% This function is a drop-in replacement for fread, but by default, it
%   fseeks instead of freading, unless you pass read = true; It also
%   amortizes seeks as long as possible, to save time.
%
% If you need a particular fake output other than the default ([]), pass it
%   in with the OutputValue argument.
%
% See fread for detailed documentation about fid, num, and type arguments.
%
% Note that this function uses a persistent variable to keep track of 
%   amortized seeks, so you should not use this function for two separate
%   open files at the same time.
%
% See also: fread, fseek, ftell
%
% Version: 1.0
% Author:  Brian Kardon
% Email:   bmk27=cornell*org, brian*kardon=google*com
% Real_email = regexprep(Email,{'=','*'},{'@','.'})
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
arguments
    fid
    num = 1
    type = 'int8'
    read = false
    options.OutputValue = []
end
persistent skip
persistent fid_saved

if istext(fid)
    switch fid
        case 'reset'
            fid_saved = [];
            skip = 0;
        case 'skip'
            if skip > 0
                if isempty(fid_saved)
                    error('You must call fskim at least once with a valid fid before ordering a skip');
                end
                fseek(fid_saved, skip, 'cof');
                skip = 0;
            end
    end
    return;
else
    fid_saved = fid;
end

if isempty(skip)
    % Initialize skip
    skip = 0;
end

if read
    % Actually read data
    if skip > 0
        % Skip the amount we've tallied up
        fseek(fid_saved, skip, 'cof');
        skip = 0;
    end
    % Read data
    out = fread(fid_saved, num, type);
    return;
end

% Not actually reading, just record how many bytes we're going to have to skip
out = options.OutputValue;

switch type
    case 'uint'
        bytesPerBlock = 4;
    case 'uint8'
        bytesPerBlock = 1;
    case 'uint16'
        bytesPerBlock = 2;
    case 'uint32'
        bytesPerBlock = 4;
    case 'uint64'
        bytesPerBlock = 8;
    case 'uchar'
        bytesPerBlock = 1;
    case 'unsigned char'
        bytesPerBlock = 1;
    case 'ushort'
        bytesPerBlock = 2;
    case 'ulong'
        bytesPerBlock = 4;
    case 'int'
        bytesPerBlock = 4;
    case 'int8'
        bytesPerBlock = 1;
    case 'int16'
        bytesPerBlock = 2;
    case 'int32'
        bytesPerBlock = 4;
    case 'int64'
        bytesPerBlock = 8;
    case 'integer*1'
        bytesPerBlock = 1;
    case 'integer*2'
        bytesPerBlock = 2;
    case 'integer*4'
        bytesPerBlock = 4;
    case 'integer*8'
        bytesPerBlock = 8;
    case 'schar'
        bytesPerBlock = 1;
    case 'signed char'
        bytesPerBlock = 1;
    case 'short'
        bytesPerBlock = 2;
    case 'long'
        bytesPerBlock = 4;
    case 'single'
        bytesPerBlock = 4;
    case 'double'
        bytesPerBlock = 8;
    case 'float'
        bytesPerBlock = 4;
    case 'float32'
        bytesPerBlock = 4;
    case 'float64'
        bytesPerBlock = 8;
    case 'real*4'
        bytesPerBlock = 4;
    case 'real*8'
        bytesPerBlock = 8;
    case 'char*1'
        bytesPerBlock = 1;
    otherwise
        error('Invalid data type: %s', type);
end

if ~isscalar(num)
    num = prod(num);
end

skip = skip + bytesPerBlock * num;
